---
title: "Homework 4"
author: "Andrew Harvey"
date: "25 June 2024"
format: html
editor: visual
---
```{r Load Libraries, warning=FALSE}
library(tidyverse)
```
# Task 1 - Conceptual Questions

## Questions

1. What is the purpose of the lapply() function? What is the equivalent purrr function?

* <mark>The lapply() function takes in a list, and a function then applys the function to each element of the list, it then returns a list where each element is the output from the function. The equivalent purr function is map().<mark>

2. Suppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = "kendall") on each element of the list. Write code to do this below! (Iâ€™m really trying to ask you how you specify method = "kendall" when calling lapply()).

* <mark> lapply(my_list, FUN = cor, method = "kendall") <mark>

3. What are two advantages of using purrr functions instead of the BaseR apply family?

* <mark> The first advantage is that the purr functions are consistent while the apply family is not. Hadley gives the example of `lapply()` and `mapply()` where `lappy()` has the first argument being data and `mapply()` has the function as the first argument. Purr functions always have data as the first argument. Second, you can predict the output of the purr functions where the same can not be said for the apply family functions. [Source](https://stackoverflow.com/questions/45101045/why-use-purrrmap-instead-of-lapply) <mark>

4. What is a side-effect function?

* <mark> A side-effect function is a function where some output or other task is presented but nothing is done to the data. `Print()`, `cat()`, and  `plot()` are examples of side-effect functions.<mark>

5. Why can you name a variable sd in a function and not cause any issues with the sd function?

* <mark> A variable can be named sd within a function and not cause issues with the sd function because the sd within your function is local to your function's environment while the sd function exists within the stats package which is a parent environment. <mark>


# Task 2 - Writing R Functions

1. When we start doing machine learning later in the course, a common metric used to evaluate predictions is called Root Mean Square Error (RMSE). For a given set of responses, $y_1$, ..., $y_n$ (variable of interest that we want to predict) and a set of corresponding predictions for those observations, $\hat{y_1}$, ..., $\hat{y_n}$ the RMSE is defined as $$RMSE = \sqrt{\frac{1}{n}\sum_{i=1}^{n}(y_i-\hat{y_i})^2}$$ Write a basic function (call it getRMSE()) that takes in a *vector* of responses and a *vector* of predictions and outputs the RMSE.

* If a value is missing for the vector of responses (i.e. an NA is present), allow for additional arguments to the **mean()** function (ellipses) that removes the **NA** values in the computation.

<mark>Create the RMSE function with an ellipsis argument to enable additional arguments to be passed. Add the ellipsis argument to the mean function. Returns the RMSE.<mark>

```{r RMSE Function}
getRMSE<-function(vec1,vec2,...){
  #rmse <- sqrt(1/length(vec1)*((mean(vec1-vec2,...))^2))
  rmse <- sqrt(mean((vec1-vec2)^2,...))
  rmse
}
```

2. Run the following code to create some response values and predictions.

```{r Create random # vector and linear model vector}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10*x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

* Test your RMSE function using this data. 
<mark> Quickly tests the RMSE function by passing in the response and prediction vectors.<mark>

```{r Test RMSE function}
getRMSE(resp,pred)
```

* Repeat after replacing two of the response values with missing values (NA_real_).

<mark> Assigned NA value to two random locations in the response vector.<mark>

```{r Assign missing values}
# For loop to randomly select 2 elements of resp to make NA
for (i in 1:2) {
  j<-ceiling(runif(1,min = 1, max = 100))
  resp[j]<-NA_real_
}
# Check resp
resp

```

  -- Test your RMSE function with and without specifying the behavior to deal with missing values.
  
  <mark> Tests the function without and with removal of missing values. When missing values are present the function should return "NA" and when missing values are removed the function should return a double. <mark>
```{r Test RMSE function with and without na.rm}
# Test RMSE with NA vector
getRMSE(resp,pred)

# Test RMSE with additional na.rm argument
getRMSE(resp,pred,na.rm=TRUE)
```

3. Another common metric for evaluating predictions is mean absolute deviation given by $$MAE = \frac{1}{n}\sum_{i=1}^{n}|y_i-\hat{y_i}|$$ Write a function called `getMAE()` that follows the specification of the `getRMSE()` function. 

<mark> Create the MAE function with ellipses to allow additional arguments. <mark>

```{r MAE function}
getMAE<- function(vec1,vec2,...){
  mae<- mean(abs(vec1-vec2),...)
  mae
}
```

4. Run the following code to create some response values and predictions. 

```{r Create response adn prediction values}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10*x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

* Test your MAE function using this data.

<mark> Test the `getMAE` function, should return a double. <mark>

```{r Test MAE}
getMAE(resp, pred)
```

* Repeat after replacing two of the response values with missing values (`NA_real_`).

<mark> Assigned NA value to two random locations in the response vector.<mark>

```{r Replace}
# For loop to randomly select 2 elements of resp to make NA
for (i in 1:2) {
  j<-ceiling(runif(1,min = 1, max = 100))
  resp[j]<-NA_real_
}
# Check resp
resp
```
  -- Test your MAE function with and without specifying the behavior to deal with missing values.
  
  <mark> Tests the function without and with removal of missing values. When missing values are present the function should return "NA" and when missing values are removed the function should return a double. <mark>
  
```{r Test MAE function with adn without na.rm}
getMAE(resp, pred)
getMAE(resp,pred,na.rm = TRUE)
```

5. Let's create a **wrapper** function that can be used to get either or both metrics returned with a single function call. Do not rewrite your above two function, call them inside the wrapper function (we would call the `getRMSE()` and `getMAE()` function **helper** functions). When returning your Values, giving them appropriate names.

* The function should check that two numeric (atomic) vectors have been passed (consider `is.vector()`,`is.atomic()`, and `is.numeric()`). If not, a message should print and the function should exit. 
* The function should return both metrics by default and include names. The behavior should be able to be changed using a character string of metrics to find. 

<mark> Create a wrapper function. Function has two if/else statements. The first if/else checks if the passed functions are atomic, numeric vectors. If either of the passed arguments are not one of those three conditions then it will stop running and return an error stating which condition it did not meet. The second if/else statement determines which function, `getMAE()` or `getRMSE()`, to call. If it is not specified then it will return both functions. <mark>
```{r Wrapper function}
my_wrapper<- function(vec1,vec2,fun = NULL,...){
  if(!is.vector(vec1) | !is.vector(vec2)){
    stop("Error: One or more arguments is not a vector")
  }
  else if(!is.numeric(vec1) | !is.numeric(vec2)){
    stop("Error: One or more arguments is not numeric")
  }
  else if(!is.atomic(vec1) | !is.atomic(vec2)){
    stop("Error: One or more arguments is not atomic")
  }
  
  if(!is.null(fun)){
    my_fun <- get(fun)
    cat(gsub("get",'',fun), my_fun(vec1,vec2,...),"\n\n")
    }
  else{
    return_val<-list(getMAE(vec1,vec2,...),
                     getRMSE(vec1,vec2,...))
    names(return_val)<-c("MAE","RMSE")
    return(return_val[])
  }
}

```

6. Run the following code to create some response values and predictions. 

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10*x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

* Test your new function using this data. Call it once asking for each metric individually and one specifying both metrics.

<mark> Tests the wrapper function. <mark>

```{r Test Wrapper}
my_wrapper(resp, pred,"getMAE")

my_wrapper(resp, pred,"getRMSE")

my_wrapper(resp, pred)
```
* Repeat with replacing two of the response values with missing values (`NA_real_`).

```{r Replace two response values w/ NA}
# For loop to randomly select 2 elements of resp to make NA
for (i in 1:2) {
  j<-runif(1,min = 1, max = 100)
  resp[j]<-NA_real_
}
# Check response values
resp
```

*Finally, test your function by passing it incorrect data (i.e a data frame or something else instead of vectors).

<mark> Test function, which should return an error message. <mark>

```{r Test function with incorrect data, error=TRUE}
# Force resp to be a matrix
resp<-as.matrix(resp)

# Test wrapper function
my_wrapper(resp, pred,"getMAE")

```

# Task 3 - Querying an API and a Tidy-Style Function

For this section, you'll connect to the news API here: [newsapi.org](https://newsapi.org/). You'll need to go to register for a key at that web site!

1. Use `Get()` from the `httr` package to return information about a topic that you are interested in that has been in the new lately (store the result as an R object). Note: We can only look 30 days into the past with a free account. 

```{r}
#load httr package
library(httr)
#contact API and search for articles containing "military"
news_search_military<- GET("https://newsapi.org/v2/everything?q=military&apiKey=6960626c89a2457397c4a992e8b46363")
```

2. Parse what is returned and find you way to the data frame that has the actual article information in it (check `content`). Note the first column should be a list column!

```{r}
library(jsonlite)
str(news_search_military,max.level = 1)
parsed<-as_tibble(fromJSON(rawToChar(news_search_military$content)))
parsed<-parsed$articles|>
  select(-source)
parsed
```

3. Now write a quick function that allows the user to easily query this API. The inputs to the function should be the title/subject to search for (string), a time period to search from (string - you'll search from that time until the present), and an API key.

```{r API Search Function}
search_NewsAPI <- function(title, date=today("UTC"), APIkey = "6960626c89a2457397c4a992e8b46363"){
  keyword<-as.character(title)
  fromTime<-as.character(date)
  toTime<-as.character(today()-days(30))
  APIkey<-as.character(APIkey)
  .x<- httr::GET(paste0("https://newsapi.org/v2/everything?q=",keyword,"&from=",fromTime,"to=",toTime,"&apiKey=",APIkey))
  
  .d<-as_tibble(fromJSON(rawToChar(.x$content)))
  .d<-.d$articles|>
    select(-source)
  return(.d)
}
```

```{r Test function}
#test just using keyword
search_NewsAPI("Army")

# test using keyword and date
search_NewsAPI("monkey","2024-05-30")

```

